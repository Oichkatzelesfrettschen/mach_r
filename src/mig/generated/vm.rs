// @generated by xtask mig
// module: vm

use crate::port::Port;
use alloc::sync::Arc;
use crate::message::Message;

pub const ALLOCATE_ID: u32 = 2000;
pub const DEALLOCATE_ID: u32 = 2001;
pub const PROTECT_ID: u32 = 2002;

pub trait NameService {
    fn allocate(&self, size: u64, protection: u32) -> Result<u64, i32>;
    fn deallocate(&self, addr: u64, size: u64) -> i32;
    fn protect(&self, addr: u64, size: u64, protection: u32) -> i32;
}

pub struct NameClient { server: Arc<Port> }

impl NameClient {
    pub fn new(server: Arc<Port>) -> Self { Self { server } }
    // unsupported routine allocate
    // unsupported routine deallocate
    // unsupported routine protect
    pub fn allocate_call(&self, size: u64, prot: u32, reply: &Arc<Port>) -> Result<u64, i32> {
        let mut data = alloc::vec::Vec::new();
        data.extend_from_slice(&(ALLOCATE_ID as u32).to_le_bytes());
        data.extend_from_slice(&size.to_le_bytes());
        data.extend_from_slice(&prot.to_le_bytes());
        let msg = Message::new_out_of_line(self.server.id(), data).with_reply_port(reply.id());
        if self.server.send(msg).is_err() { return Err(-1); }
        if let Some(rep) = reply.receive() { let d = rep.data(); if d.len()>=4 { let mut rc=[0;4]; rc.copy_from_slice(&d[0..4]); let code=i32::from_le_bytes(rc); if code==0 { if d.len()>=12 { let mut ab=[0u8;8]; ab.copy_from_slice(&d[4..12]); return Ok(u64::from_le_bytes(ab)); } else { return Err(-1);} } else { return Err(code);} } }
        Err(-1)
    }
    pub fn deallocate_call(&self, addr: u64, size: u64, reply: &Arc<Port>) -> i32 {
        let mut data = alloc::vec::Vec::new();
        data.extend_from_slice(&(DEALLOCATE_ID as u32).to_le_bytes());
        data.extend_from_slice(&addr.to_le_bytes());
        data.extend_from_slice(&size.to_le_bytes());
        let msg = Message::new_out_of_line(self.server.id(), data).with_reply_port(reply.id());
        if self.server.send(msg).is_err() { return -1; }
        if let Some(rep) = reply.receive() { let d=rep.data(); if d.len()>=4 { let mut rc=[0;4]; rc.copy_from_slice(&d[0..4]); return i32::from_le_bytes(rc);} }
        -1
    }
    pub fn protect_call(&self, addr: u64, size: u64, prot: u32, reply: &Arc<Port>) -> i32 {
        let mut data = alloc::vec::Vec::new();
        data.extend_from_slice(&(PROTECT_ID as u32).to_le_bytes());
        data.extend_from_slice(&addr.to_le_bytes());
        data.extend_from_slice(&size.to_le_bytes());
        data.extend_from_slice(&prot.to_le_bytes());
        let msg = Message::new_out_of_line(self.server.id(), data).with_reply_port(reply.id());
        if self.server.send(msg).is_err() { return -1; }
        if let Some(rep) = reply.receive() { let d=rep.data(); if d.len()>=4 { let mut rc=[0;4]; rc.copy_from_slice(&d[0..4]); return i32::from_le_bytes(rc);} }
        -1
    }
}

pub fn dispatch<T: NameService>(svc: &T, msg: &Message) -> Option<Message> {
    let data = msg.data();
    if data.len() < 4 { return None; }
    let mut idb = [0u8;4]; idb.copy_from_slice(&data[0..4]);
    let msg_id = u32::from_le_bytes(idb);
    let mut off = 4usize;
    let reply_to = msg.header.local_port.unwrap_or(msg.remote_port());
    match msg_id {
        ALLOCATE_ID => {
            if data.len() < off + 12 { return None; }
            let mut sb=[0u8;8]; sb.copy_from_slice(&data[off..off+8]); off+=8;
            let size = u64::from_le_bytes(sb);
            let mut pb=[0u8;4]; pb.copy_from_slice(&data[off..off+4]); let _ = off + 4;
            let prot = u32::from_le_bytes(pb);
            let res = svc.allocate(size, prot);
            let mut out = alloc::vec::Vec::new();
            match res { Ok(addr) => { out.extend_from_slice(&(0i32).to_le_bytes()); out.extend_from_slice(&addr.to_le_bytes()); }, Err(e) => { out.extend_from_slice(&(e as i32).to_le_bytes()); } }
            return Some(Message::new_out_of_line(reply_to, out));
        }
        DEALLOCATE_ID => {
            if data.len() < off + 16 { return None; }
            let mut ab=[0u8;8]; ab.copy_from_slice(&data[off..off+8]); off+=8;
            let addr = u64::from_le_bytes(ab);
            let mut sb=[0u8;8]; sb.copy_from_slice(&data[off..off+8]); let _ = off + 8;
            let size = u64::from_le_bytes(sb);
            let rc = svc.deallocate(addr, size);
            let mut out = alloc::vec::Vec::new(); out.extend_from_slice(&(rc as i32).to_le_bytes());
            return Some(Message::new_out_of_line(reply_to, out));
        }
        PROTECT_ID => {
            if data.len() < off + 20 { return None; }
            let mut ab=[0u8;8]; ab.copy_from_slice(&data[off..off+8]); off+=8;
            let addr = u64::from_le_bytes(ab);
            let mut sb=[0u8;8]; sb.copy_from_slice(&data[off..off+8]); off+=8;
            let size = u64::from_le_bytes(sb);
            let mut pb=[0u8;4]; pb.copy_from_slice(&data[off..off+4]); let _ = off + 4;
            let prot = u32::from_le_bytes(pb);
            let rc = svc.protect(addr, size, prot);
            let mut out = alloc::vec::Vec::new(); out.extend_from_slice(&(rc as i32).to_le_bytes());
            return Some(Message::new_out_of_line(reply_to, out));
        }
        _ => None,
    }
}