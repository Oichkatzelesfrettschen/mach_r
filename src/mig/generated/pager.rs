// @generated by xtask mig
// module: pager

use crate::types::PortId;
use crate::port::Port;
use alloc::sync::Arc;
use crate::message::Message;

pub const PAGE_REQUEST_ID: u32 = 4000;

pub trait NameService {
    fn page_request(&self, object_id: u64, offset: u64, size: u32, protection: u32) -> Result<u64, i32>;
}

pub struct NameClient { server: Arc<Port> }

impl NameClient {
    pub fn new(server: Arc<Port>) -> Self { Self { server } }
    // unsupported routine page_request
    pub fn page_request_call(&self, object_id: u64, offset: u64, size: u32, prot: u32, reply: &Arc<Port>) -> Result<u64, i32> {
        let mut data = alloc::vec::Vec::new();
        data.extend_from_slice(&(PAGE_REQUEST_ID as u32).to_le_bytes());
        data.extend_from_slice(&object_id.to_le_bytes());
        data.extend_from_slice(&offset.to_le_bytes());
        data.extend_from_slice(&size.to_le_bytes());
        data.extend_from_slice(&prot.to_le_bytes());
        let msg = Message::new_out_of_line(self.server.id(), data).with_reply_port(reply.id());
        if self.server.send(msg).is_err() { return Err(-1); }
        if let Some(rep) = reply.receive() { let d = rep.data(); if d.len()>=4 { let mut rc=[0;4]; rc.copy_from_slice(&d[0..4]); let code=i32::from_le_bytes(rc); if code==0 { if d.len()>=12 { let mut pb=[0u8;8]; pb.copy_from_slice(&d[4..12]); return Ok(u64::from_le_bytes(pb)); } else { return Err(-1); } } else { return Err(code); } } }
        Err(-1)
    }
}

pub fn dispatch<T: NameService>(svc: &T, msg: &Message) -> Option<Message> {
    let data = msg.data();
    if data.len() < 4 { return None; }
    let mut idb = [0u8;4]; idb.copy_from_slice(&data[0..4]);
    let msg_id = u32::from_le_bytes(idb);
    let mut off = 4usize;
    let reply_to = msg.header.local_port.unwrap_or(msg.remote_port());
    match msg_id {
        PAGE_REQUEST_ID => {
            if data.len() < off + 24 { return None; }
            let mut ob=[0u8;8]; ob.copy_from_slice(&data[off..off+8]); off+=8;
            let object_id = u64::from_le_bytes(ob);
            let mut offb=[0u8;8]; offb.copy_from_slice(&data[off..off+8]); off+=8;
            let offset = u64::from_le_bytes(offb);
            let mut sb=[0u8;4]; sb.copy_from_slice(&data[off..off+4]); off+=4;
            let size = u32::from_le_bytes(sb);
            let mut pb=[0u8;4]; pb.copy_from_slice(&data[off..off+4]); off+=4;
            let prot = u32::from_le_bytes(pb);
            let res = svc.page_request(object_id, offset, size, prot);
            let mut out = alloc::vec::Vec::new();
            match res { Ok(pa) => { out.extend_from_slice(&(0i32).to_le_bytes()); out.extend_from_slice(&pa.to_le_bytes()); }, Err(e) => { out.extend_from_slice(&(e as i32).to_le_bytes()); } }
            return Some(Message::new_out_of_line(reply_to, out));
        }
        _ => None,
    }
}