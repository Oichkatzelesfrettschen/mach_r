// @generated by xtask mig
// module: name_server

use crate::types::PortId;
use crate::port::Port;
use alloc::sync::Arc;
use crate::message::Message;

pub const REGISTER_ID: u32 = 1000;
pub const LOOKUP_ID: u32 = 1001;
pub const UNREGISTER_ID: u32 = 1002;

pub trait NameService {
    fn register(&self, name: &str, port: PortId) -> i32;
    fn lookup(&self, name: &str) -> Result<PortId, i32>;
    fn unregister(&self, name: &str) -> i32;
}

pub struct NameClient { server: Arc<Port> }

impl NameClient {
    pub fn new(server: Arc<Port>) -> Self { Self { server } }
    pub fn register(&self, name: &str, port: PortId) -> Result<(), i32> {
        let mut data = alloc::vec::Vec::new();
        data.extend_from_slice(&(REGISTER_ID as u32).to_le_bytes());
        data.extend_from_slice(&(name.len() as u32).to_le_bytes());
        data.extend_from_slice(name.as_bytes());
        data.extend_from_slice(&(port.0 as u64).to_le_bytes());
        let msg = Message::new_out_of_line(self.server.id(), data);
        self.server.send(msg).map_err(|_| -1)?;
        Ok(())
    }

    pub fn lookup(&self, name: &str) -> Result<PortId, i32> {
        let mut data = alloc::vec::Vec::new();
        data.extend_from_slice(&(LOOKUP_ID as u32).to_le_bytes());
        data.extend_from_slice(&(name.len() as u32).to_le_bytes());
        data.extend_from_slice(name.as_bytes());
        let msg = Message::new_out_of_line(self.server.id(), data);
        self.server.send(msg).map_err(|_| -1)?;
        Ok(PortId(0))
    }

    pub fn unregister(&self, name: &str) -> Result<(), i32> {
        let mut data = alloc::vec::Vec::new();
        data.extend_from_slice(&(UNREGISTER_ID as u32).to_le_bytes());
        data.extend_from_slice(&(name.len() as u32).to_le_bytes());
        data.extend_from_slice(name.as_bytes());
        let msg = Message::new_out_of_line(self.server.id(), data);
        self.server.send(msg).map_err(|_| -1)?;
        Ok(())
    }

    pub fn register_call(&self, name: &str, port: PortId, reply: &Arc<Port>) -> i32 {
        let mut data = alloc::vec::Vec::new();
        data.extend_from_slice(&(REGISTER_ID as u32).to_le_bytes());
        data.extend_from_slice(&(name.len() as u32).to_le_bytes());
        data.extend_from_slice(name.as_bytes());
        data.extend_from_slice(&(port.0 as u64).to_le_bytes());
        let msg = Message::new_out_of_line(self.server.id(), data).with_reply_port(reply.id());
        if self.server.send(msg).is_err() { return -1; }
        if let Some(rep) = reply.receive() { let d = rep.data(); if d.len()>=4 { let mut rc=[0;4]; rc.copy_from_slice(&d[0..4]); return i32::from_le_bytes(rc);} }
        -1
    }
    pub fn lookup_call(&self, name: &str, reply: &Arc<Port>) -> Result<PortId, i32> {
        let mut data = alloc::vec::Vec::new();
        data.extend_from_slice(&(LOOKUP_ID as u32).to_le_bytes());
        data.extend_from_slice(&(name.len() as u32).to_le_bytes());
        data.extend_from_slice(name.as_bytes());
        let msg = Message::new_out_of_line(self.server.id(), data).with_reply_port(reply.id());
        if self.server.send(msg).is_err() { return Err(-1); }
        if let Some(rep) = reply.receive() { let d = rep.data(); if d.len()>=4 { let mut rc=[0;4]; rc.copy_from_slice(&d[0..4]); let code=i32::from_le_bytes(rc); if code==0 { if d.len()>=12 { let mut pb=[0u8;8]; pb.copy_from_slice(&d[4..12]); return Ok(PortId(u64::from_le_bytes(pb))); } else { return Err(-1); } } else { return Err(code); } } }
        Err(-1)
    }
    pub fn unregister_call(&self, name: &str, reply: &Arc<Port>) -> i32 {
        let mut data = alloc::vec::Vec::new();
        data.extend_from_slice(&(UNREGISTER_ID as u32).to_le_bytes());
        data.extend_from_slice(&(name.len() as u32).to_le_bytes());
        data.extend_from_slice(name.as_bytes());
        let msg = Message::new_out_of_line(self.server.id(), data).with_reply_port(reply.id());
        if self.server.send(msg).is_err() { return -1; }
        if let Some(rep) = reply.receive() { let d = rep.data(); if d.len()>=4 { let mut rc=[0;4]; rc.copy_from_slice(&d[0..4]); return i32::from_le_bytes(rc);} }
        -1
    }
}

pub fn dispatch<T: NameService>(svc: &T, msg: &Message) -> Option<Message> {
    let data = msg.data();
    if data.len() < 4 { return None; }
    let mut idb = [0u8;4]; idb.copy_from_slice(&data[0..4]);
    let msg_id = u32::from_le_bytes(idb);
    let mut off = 4usize;
    let reply_to = msg.header.local_port.unwrap_or(msg.remote_port());
    match msg_id {
        REGISTER_ID => {
            if data.len() < off + 4 { return None; }
            let mut lb=[0u8;4]; lb.copy_from_slice(&data[off..off+4]); off+=4;
            let nlen = u32::from_le_bytes(lb) as usize;
            if data.len() < off + nlen + 8 { return None; }
            let name = core::str::from_utf8(&data[off..off+nlen]).ok()?; off+=nlen;
            let mut pb=[0u8;8]; pb.copy_from_slice(&data[off..off+8]); off+=8;
            let port = PortId(u64::from_le_bytes(pb));
            let rc = svc.register(name, port);
            let mut out = alloc::vec::Vec::new();
            out.extend_from_slice(&(rc as i32).to_le_bytes());
            out.extend_from_slice(&(port.0 as u64).to_le_bytes());
            return Some(Message::new_out_of_line(reply_to, out));
        }
        LOOKUP_ID => {
            if data.len() < off + 4 { return None; }
            let mut lb=[0u8;4]; lb.copy_from_slice(&data[off..off+4]); off+=4;
            let nlen = u32::from_le_bytes(lb) as usize;
            if data.len() < off + nlen { return None; }
            let name = core::str::from_utf8(&data[off..off+nlen]).ok()?; off+=nlen;
            match svc.lookup(name) {
                Ok(pid) => {
                    let mut out = alloc::vec::Vec::new();
                    out.extend_from_slice(&(0i32).to_le_bytes());
                    out.extend_from_slice(&(pid.0 as u64).to_le_bytes());
                    return Some(Message::new_out_of_line(reply_to, out));
                }
                Err(e) => {
                    let mut out = alloc::vec::Vec::new();
                    out.extend_from_slice(&(e as i32).to_le_bytes());
                    return Some(Message::new_out_of_line(reply_to, out));
                }
            }
        }
        UNREGISTER_ID => {
            if data.len() < off + 4 { return None; }
            let mut lb=[0u8;4]; lb.copy_from_slice(&data[off..off+4]); off+=4;
            let nlen = u32::from_le_bytes(lb) as usize;
            if data.len() < off + nlen { return None; }
            let name = core::str::from_utf8(&data[off..off+nlen]).ok()?; off+=nlen;
            let rc = svc.unregister(name);
            let mut out = alloc::vec::Vec::new();
            out.extend_from_slice(&(rc as i32).to_le_bytes());
            return Some(Message::new_out_of_line(reply_to, out));
        }
        _ => None,
    }
}