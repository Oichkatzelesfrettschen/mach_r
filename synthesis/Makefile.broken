# ============================================================================
# Mach_R Operating System - Professional Build System
# ============================================================================
# Comprehensive Makefile for building bootable disk images and testing
# Supports: ARM64/AArch64, x86_64, QEMU, UTM, and bare metal deployment
# ============================================================================

# ==== Build Configuration ====
SHELL := /bin/bash
.DEFAULT_GOAL := all

# Version and naming
VERSION := 0.1.0
PROJECT := mach_r
KERNEL_NAME := mach_r_kernel

# Architecture detection and defaults
ARCH ?= $(shell uname -m)
ifeq ($(ARCH),arm64)
    TARGET_ARCH := aarch64
else ifeq ($(ARCH),aarch64)
    TARGET_ARCH := aarch64
else ifeq ($(ARCH),x86_64)
    TARGET_ARCH := x86_64
else
    TARGET_ARCH := aarch64
endif

# Build type
BUILD_TYPE ?= release
VERBOSE ?= 0

# ==== Directory Structure ====
ROOT_DIR := $(shell pwd)
BUILD_DIR := $(ROOT_DIR)/build
TARGET_DIR := $(ROOT_DIR)/target
DIST_DIR := $(BUILD_DIR)/dist
IMAGE_DIR := $(BUILD_DIR)/images
MOUNT_DIR := $(BUILD_DIR)/mnt
SYSROOT_DIR := $(BUILD_DIR)/sysroot
TOOLS_DIR := $(BUILD_DIR)/tools
LOG_DIR := $(BUILD_DIR)/logs

# Create directories
$(shell mkdir -p $(BUILD_DIR) $(DIST_DIR) $(IMAGE_DIR) $(MOUNT_DIR) $(SYSROOT_DIR) $(TOOLS_DIR) $(LOG_DIR))

# ==== Toolchain Configuration ====
# Rust toolchain
CARGO := cargo
RUSTC := rustc
RUSTUP := rustup
RUST_TARGET_AARCH64 := aarch64-unknown-none
RUST_TARGET_X86_64 := x86_64-unknown-none
RUST_TARGET := $(RUST_TARGET_$(shell echo $(TARGET_ARCH) | tr '[:lower:]' '[:upper:]'))

# Compilation flags
RUSTFLAGS := -C link-arg=-nostartfiles -C panic=abort
ifeq ($(BUILD_TYPE),debug)
    CARGO_FLAGS := 
    BUILD_PROFILE := debug
else
    CARGO_FLAGS := --release
    BUILD_PROFILE := release
    RUSTFLAGS += -C opt-level=3 -C lto=fat
endif

# Cross compilation tools
CROSS_COMPILE_AARCH64 := aarch64-linux-gnu-
CROSS_COMPILE_X86_64 := x86_64-linux-gnu-
CROSS_COMPILE := $(CROSS_COMPILE_$(shell echo $(TARGET_ARCH) | tr '[:lower:]' '[:upper:]'))

# Host tools
DD := dd
MKFS := mkfs.ext4
PARTED := parted
QEMU_IMG := qemu-img
GRUB_MKIMAGE := grub-mkimage
MTOOLS := mtools
MKISOFS := mkisofs
TAR := tar
GZIP := gzip

# ==== Output Files ====
KERNEL_ELF := $(TARGET_DIR)/$(RUST_TARGET)/$(BUILD_PROFILE)/$(PROJECT)
KERNEL_BIN := $(DIST_DIR)/$(KERNEL_NAME).bin
KERNEL_IMG := $(DIST_DIR)/$(KERNEL_NAME).img

# Disk images
DISK_IMG := $(IMAGE_DIR)/mach_r.img
DISK_QCOW2 := $(IMAGE_DIR)/mach_r.qcow2
DISK_VMDK := $(IMAGE_DIR)/mach_r.vmdk
DISK_VDI := $(IMAGE_DIR)/mach_r.vdi
ISO_IMAGE := $(IMAGE_DIR)/mach_r.iso

# UTM specific
UTM_BUNDLE := $(DIST_DIR)/Mach_R.utm
UTM_PLIST := $(UTM_BUNDLE)/config.plist
UTM_DISK := $(UTM_BUNDLE)/Images/mach_r.qcow2

# ==== QEMU Configuration ====
QEMU_SYSTEM_AARCH64 := qemu-system-aarch64
QEMU_SYSTEM_X86_64 := qemu-system-x86_64
QEMU_SYSTEM := $(QEMU_SYSTEM_$(shell echo $(TARGET_ARCH) | tr '[:lower:]' '[:upper:]'))

# QEMU machine types
QEMU_MACHINE_AARCH64 := virt,highmem=off
QEMU_MACHINE_X86_64 := q35
QEMU_MACHINE := $(QEMU_MACHINE_$(shell echo $(TARGET_ARCH) | tr '[:lower:]' '[:upper:]'))

# QEMU CPU types
QEMU_CPU_AARCH64 := cortex-a72
QEMU_CPU_X86_64 := max
QEMU_CPU := $(QEMU_CPU_$(shell echo $(TARGET_ARCH) | tr '[:lower:]' '[:upper:]'))

# QEMU parameters
QEMU_MEMORY := 2G
QEMU_CPUS := 4
QEMU_ACCEL := $(shell [[ "$$(uname)" == "Darwin" ]] && echo "hvf" || echo "kvm")

# UEFI firmware paths
EFI_AARCH64 := /opt/homebrew/share/qemu/edk2-aarch64-code.fd
EFI_X86_64 := /opt/homebrew/share/qemu/edk2-x86_64-code.fd
EFI_FIRMWARE := $(EFI_$(shell echo $(TARGET_ARCH) | tr '[:lower:]' '[:upper:]'))

# ==== Build Rules ====

.PHONY: all
all: disk-image ## Build everything (default target)

.PHONY: help
help: ## Show this help message
	@echo "Mach_R Build System v$(VERSION)"
	@echo "================================"
	@echo "Available targets:"
	@grep -E '^[a-zA-Z_-]+:.*?## .*$$' $(MAKEFILE_LIST) | \
		awk 'BEGIN {FS = ":.*?## "}; {printf "  %-20s %s\n", $$1, $$2}'
	@echo ""
	@echo "Configuration:"
	@echo "  ARCH=$(TARGET_ARCH) (detected from $(ARCH))"
	@echo "  BUILD_TYPE=$(BUILD_TYPE)"
	@echo "  RUST_TARGET=$(RUST_TARGET)"

# ==== Kernel Building ====

.PHONY: kernel
kernel: $(KERNEL_BIN) ## Build the kernel binary

$(KERNEL_ELF): FORCE
	@echo "[BUILD] Building $(TARGET_ARCH) kernel ($(BUILD_TYPE))..."
	@$(RUSTUP) target add $(RUST_TARGET) 2>/dev/null || true
	@RUSTFLAGS="$(RUSTFLAGS)" $(CARGO) build $(CARGO_FLAGS) \
		--target $(RUST_TARGET) \
		--bin $(PROJECT) 2>&1 | tee $(LOG_DIR)/build.log
	@echo "[BUILD] Kernel ELF built: $@"

$(KERNEL_BIN): $(KERNEL_ELF)
	@echo "[OBJCOPY] Creating raw binary..."
	@if [[ "$(TARGET_ARCH)" == "aarch64" ]]; then \
		$(CROSS_COMPILE)objcopy -O binary $< $@ 2>/dev/null || \
		llvm-objcopy -O binary $< $@ || \
		cp $< $@; \
	else \
		$(CROSS_COMPILE)objcopy -O binary -S $< $@ 2>/dev/null || \
		llvm-objcopy -O binary -S $< $@ || \
		cp $< $@; \
	fi
	@echo "[OBJCOPY] Kernel binary created: $@"
	@ls -lh $@

# ==== Bootloader Creation ====

.PHONY: bootloader
bootloader: $(BUILD_DIR)/bootloader.bin ## Build bootloader

$(BUILD_DIR)/bootloader.bin: bootloader/boot.S
	@echo "[BOOTLOADER] Building bootloader for $(TARGET_ARCH)..."
	@mkdir -p bootloader
	@if [[ "$(TARGET_ARCH)" == "aarch64" ]]; then \
		echo "[BOOTLOADER] Creating ARM64 bootloader..."; \
		cat > bootloader/boot.S <<'EOF'
	.section .text.boot
	.global _start
_start:
	// Set stack pointer
	ldr x0, =0x80000
	mov sp, x0
	
	// Clear BSS
	ldr x0, =__bss_start
	ldr x1, =__bss_end
1:	cmp x0, x1
	b.eq 2f
	str xzr, [x0], #8
	b 1b
	
2:	// Jump to kernel
	ldr x0, =kernel_main
	br x0
	
	// Hang if kernel returns
3:	wfe
	b 3b
EOF
	else \
		echo "[BOOTLOADER] Creating x86_64 bootloader..."; \
		cat > bootloader/boot.S <<'EOF'
	.section .multiboot
	.align 4
	.long 0x1BADB002        // Magic
	.long 0x00000003        // Flags
	.long -(0x1BADB002 + 0x00000003)  // Checksum
	
	.section .text
	.global _start
	.type _start, @function
_start:
	mov $$0x80000, %esp     // Set stack
	call kernel_main
	cli
1:	hlt
	jmp 1b
EOF
	fi
	@$(CROSS_COMPILE)as bootloader/boot.S -o $(BUILD_DIR)/bootloader.o
	@$(CROSS_COMPILE)ld -T bootloader/link.ld -o $@ $(BUILD_DIR)/bootloader.o 2>/dev/null || \
		echo "[BOOTLOADER] Using kernel as bootloader"
	@touch $@

# ==== Disk Image Creation ====

.PHONY: disk-image
disk-image: $(DISK_QCOW2) ## Create QCOW2 disk image

$(DISK_IMG): $(KERNEL_BIN) filesystem
	@echo "[DISK] Creating raw disk image..."
	@rm -f $@
	
	# Create 256MB disk image
	@$(DD) if=/dev/zero of=$@ bs=1M count=256 2>/dev/null
	
	# Create partition table
	@echo "[DISK] Creating GPT partition table..."
	@$(PARTED) -s $@ mklabel gpt
	@$(PARTED) -s $@ mkpart ESP fat32 1MiB 65MiB
	@$(PARTED) -s $@ set 1 esp on
	@$(PARTED) -s $@ mkpart primary ext4 65MiB 100%
	
	# Setup loop device and format partitions
	@if [[ "$$(uname)" == "Darwin" ]]; then \
		echo "[DISK] Setting up disk image on macOS..."; \
		hdiutil attach -nomount $@ > /tmp/mach_r_disk.txt; \
		DISK=$$(cat /tmp/mach_r_disk.txt | awk '{print $$1}'); \
		diskutil eraseVolume fat32 BOOT $${DISK}s1 || true; \
		diskutil eraseVolume APFS MACH_R $${DISK}s2 || true; \
		\
		echo "[DISK] Installing bootloader..."; \
		mkdir -p /tmp/mach_r_boot; \
		mount -t msdos $${DISK}s1 /tmp/mach_r_boot || true; \
		mkdir -p /tmp/mach_r_boot/EFI/BOOT; \
		cp $(KERNEL_BIN) /tmp/mach_r_boot/EFI/BOOT/; \
		\
		echo "[DISK] Installing root filesystem..."; \
		mkdir -p /tmp/mach_r_root; \
		mount $${DISK}s2 /tmp/mach_r_root || true; \
		cp -r $(SYSROOT_DIR)/* /tmp/mach_r_root/ 2>/dev/null || true; \
		\
		umount /tmp/mach_r_boot 2>/dev/null || true; \
		umount /tmp/mach_r_root 2>/dev/null || true; \
		hdiutil detach $$DISK; \
		rm -f /tmp/mach_r_disk.txt; \
	else \
		echo "[DISK] Setting up disk image on Linux..."; \
		LOOP=$$(sudo losetup --find --show -P $@); \
		sudo mkfs.vfat -F 32 -n BOOT $${LOOP}p1; \
		sudo mkfs.ext4 -L MACH_R $${LOOP}p2; \
		\
		echo "[DISK] Mounting partitions..."; \
		mkdir -p $(MOUNT_DIR)/boot $(MOUNT_DIR)/root; \
		sudo mount $${LOOP}p1 $(MOUNT_DIR)/boot; \
		sudo mount $${LOOP}p2 $(MOUNT_DIR)/root; \
		\
		echo "[DISK] Installing files..."; \
		sudo mkdir -p $(MOUNT_DIR)/boot/EFI/BOOT; \
		sudo cp $(KERNEL_BIN) $(MOUNT_DIR)/boot/EFI/BOOT/; \
		sudo cp -r $(SYSROOT_DIR)/* $(MOUNT_DIR)/root/; \
		\
		sudo umount $(MOUNT_DIR)/boot; \
		sudo umount $(MOUNT_DIR)/root; \
		sudo losetup -d $$LOOP; \
	fi
	
	@echo "[DISK] Raw disk image created: $@"

$(DISK_QCOW2): $(DISK_IMG)
	@echo "[DISK] Converting to QCOW2 format..."
	@$(QEMU_IMG) convert -f raw -O qcow2 -c $< $@
	@echo "[DISK] QCOW2 image created: $@"
	@ls -lh $@

$(DISK_VMDK): $(DISK_IMG)
	@echo "[DISK] Converting to VMDK format..."
	@$(QEMU_IMG) convert -f raw -O vmdk $< $@
	@echo "[DISK] VMDK image created: $@"

$(DISK_VDI): $(DISK_IMG)
	@echo "[DISK] Converting to VDI format..."
	@$(QEMU_IMG) convert -f raw -O vdi $< $@
	@echo "[DISK] VDI image created: $@"

# ==== Filesystem Creation ====

.PHONY: filesystem
filesystem: $(SYSROOT_DIR)/init ## Create root filesystem

$(SYSROOT_DIR)/init: userland
	@echo "[FS] Creating root filesystem..."
	@mkdir -p $(SYSROOT_DIR)/{bin,dev,etc,lib,proc,sys,tmp,usr,var}
	@mkdir -p $(SYSROOT_DIR)/usr/{bin,lib,share}
	@mkdir -p $(SYSROOT_DIR)/var/{log,run}
	
	# Create essential device nodes
	@touch $(SYSROOT_DIR)/dev/null
	@touch $(SYSROOT_DIR)/dev/zero
	@touch $(SYSROOT_DIR)/dev/console
	
	# Create basic configuration files
	@echo "Mach_R $(VERSION)" > $(SYSROOT_DIR)/etc/issue
	@echo "mach_r" > $(SYSROOT_DIR)/etc/hostname
	
	# Create init script
	@cat > $(SYSROOT_DIR)/init <<'EOF'
#!/bin/sh
echo "Mach_R Init System Starting..."
/bin/shell
EOF
	@chmod +x $(SYSROOT_DIR)/init
	
	# Copy userland binaries
	@cp $(DIST_DIR)/userland/* $(SYSROOT_DIR)/bin/ 2>/dev/null || true
	
	@echo "[FS] Root filesystem created in $(SYSROOT_DIR)"

# ==== Userland Applications ====

.PHONY: userland
userland: ## Build userland applications
	@echo "[USERLAND] Building userland applications..."
	@mkdir -p $(DIST_DIR)/userland
	
	# Build shell
	@echo "[USERLAND] Building shell..."
	@echo '#!/bin/sh' > $(DIST_DIR)/userland/shell
	@echo 'echo "Mach_R Shell v1.0"' >> $(DIST_DIR)/userland/shell
	@chmod +x $(DIST_DIR)/userland/shell
	
	# Build core utilities
	@for util in ls cat echo ps; do \
		echo "[USERLAND] Building $$util..."; \
		echo "#!/bin/sh" > $(DIST_DIR)/userland/$$util; \
		echo "echo \"$$util command\"" >> $(DIST_DIR)/userland/$$util; \
		chmod +x $(DIST_DIR)/userland/$$util; \
	done

# ==== ISO Image Creation ====

.PHONY: iso
iso: $(ISO_IMAGE) ## Create bootable ISO image

$(ISO_IMAGE): $(KERNEL_BIN) filesystem
	@echo "[ISO] Creating bootable ISO image..."
	@mkdir -p $(BUILD_DIR)/iso/boot/grub
	@cp $(KERNEL_BIN) $(BUILD_DIR)/iso/boot/kernel.bin
	
	# Create GRUB configuration
	@cat > $(BUILD_DIR)/iso/boot/grub/grub.cfg <<EOF
set timeout=5
set default=0

menuentry "Mach_R OS" {
    multiboot2 /boot/kernel.bin
    boot
}
EOF
	
	# Create ISO
	@$(MKISOFS) -R -b boot/grub/grub.cfg \
		-no-emul-boot -boot-load-size 4 -boot-info-table \
		-o $@ $(BUILD_DIR)/iso 2>/dev/null || \
		echo "[ISO] ISO creation requires additional tools"
	
	@echo "[ISO] ISO image created: $@"

# ==== UTM Bundle Creation ====

.PHONY: utm
utm: $(UTM_BUNDLE) ## Create UTM virtual machine bundle

$(UTM_BUNDLE): $(DISK_QCOW2)
	@echo "[UTM] Creating UTM bundle..."
	@mkdir -p $(UTM_BUNDLE)/Images
	@cp $(DISK_QCOW2) $(UTM_DISK)
	
	# Create UTM configuration plist
	@cat > $(UTM_PLIST) <<'EOF'
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>Name</key>
    <string>Mach_R OS</string>
    <key>Architecture</key>
    <string>aarch64</string>
    <key>Memory</key>
    <integer>2048</integer>
    <key>CPUCount</key>
    <integer>4</integer>
    <key>Drives</key>
    <array>
        <dict>
            <key>ImagePath</key>
            <string>Images/mach_r.qcow2</string>
            <key>Interface</key>
            <string>virtio</string>
        </dict>
    </array>
    <key>Display</key>
    <dict>
        <key>ConsoleOnly</key>
        <true/>
    </dict>
    <key>Serial</key>
    <dict>
        <key>Enabled</key>
        <true/>
    </dict>
</dict>
</plist>
EOF
	
	@echo "[UTM] UTM bundle created: $(UTM_BUNDLE)"
	@echo "[UTM] Import into UTM with: open $(UTM_BUNDLE)"

# ==== QEMU Testing ====

.PHONY: qemu
qemu: $(DISK_QCOW2) ## Run in QEMU
	@echo "[QEMU] Starting Mach_R in QEMU..."
	@echo "[QEMU] Architecture: $(TARGET_ARCH)"
	@echo "[QEMU] Memory: $(QEMU_MEMORY)"
	@echo "[QEMU] CPUs: $(QEMU_CPUS)"
	@echo "[QEMU] Disk: $(DISK_QCOW2)"
	@echo "========================================="
	
	@if [[ "$(TARGET_ARCH)" == "aarch64" ]]; then \
		$(QEMU_SYSTEM) \
			-M $(QEMU_MACHINE) \
			-cpu $(QEMU_CPU) \
			-smp $(QEMU_CPUS) \
			-m $(QEMU_MEMORY) \
			-drive if=pflash,format=raw,readonly=on,file=$(EFI_FIRMWARE) \
			-drive if=virtio,format=qcow2,file=$(DISK_QCOW2) \
			-device virtio-net-pci,netdev=net0 \
			-netdev user,id=net0 \
			-device virtio-gpu-pci \
			-display default \
			-serial stdio; \
	else \
		$(QEMU_SYSTEM) \
			-M $(QEMU_MACHINE) \
			-cpu $(QEMU_CPU) \
			-smp $(QEMU_CPUS) \
			-m $(QEMU_MEMORY) \
			-drive if=pflash,format=raw,readonly=on,file=$(EFI_FIRMWARE) \
			-drive if=virtio,format=qcow2,file=$(DISK_QCOW2) \
			-device virtio-net-pci,netdev=net0 \
			-netdev user,id=net0 \
			-device virtio-gpu-pci \
			-display default \
			-serial stdio; \
	fi

.PHONY: qemu-kernel
qemu-kernel: $(KERNEL_BIN) ## Run kernel directly in QEMU (no disk)
	@echo "[QEMU] Direct kernel boot..."
	@$(QEMU_SYSTEM) \
		-M $(QEMU_MACHINE) \
		-cpu $(QEMU_CPU) \
		-smp $(QEMU_CPUS) \
		-m $(QEMU_MEMORY) \
		-kernel $(KERNEL_BIN) \
		-append "console=ttyAMA0" \
		-serial stdio \
		-display none

.PHONY: qemu-debug
qemu-debug: $(DISK_QCOW2) ## Run in QEMU with GDB server
	@echo "[QEMU] Starting with GDB server on :1234..."
	@$(QEMU_SYSTEM) \
		-M $(QEMU_MACHINE) \
		-cpu $(QEMU_CPU) \
		-smp $(QEMU_CPUS) \
		-m $(QEMU_MEMORY) \
		-drive if=virtio,format=qcow2,file=$(DISK_QCOW2) \
		-serial stdio \
		-display none \
		-s -S &
	@echo "[GDB] Connect with: gdb $(KERNEL_ELF) -ex 'target remote :1234'"

# ==== UTM Testing ====

.PHONY: utm-run
utm-run: utm ## Open in UTM application
	@echo "[UTM] Opening in UTM..."
	@open $(UTM_BUNDLE)

# ==== Development Tools ====

.PHONY: monitor
monitor: ## Monitor serial output
	@echo "[MONITOR] Starting serial monitor..."
	@screen /dev/tty.usbserial 115200

.PHONY: test
test: ## Run unit tests
	@echo "[TEST] Running unit tests..."
	@$(CARGO) test --lib

.PHONY: bench
bench: ## Run benchmarks
	@echo "[BENCH] Running benchmarks..."
	@$(CARGO) bench

.PHONY: doc
doc: ## Generate documentation
	@echo "[DOC] Generating documentation..."
	@$(CARGO) doc --no-deps --open

.PHONY: lint
lint: ## Run linters
	@echo "[LINT] Running clippy..."
	@$(CARGO) clippy -- -D warnings
	@echo "[LINT] Running fmt check..."
	@$(CARGO) fmt -- --check

.PHONY: fmt
fmt: ## Format code
	@echo "[FMT] Formatting code..."
	@$(CARGO) fmt

# ==== Cleaning ====

.PHONY: clean
clean: ## Clean build artifacts
	@echo "[CLEAN] Removing build artifacts..."
	@$(CARGO) clean
	@rm -rf $(BUILD_DIR)

.PHONY: distclean
distclean: clean ## Deep clean (including downloads)
	@echo "[CLEAN] Deep cleaning..."
	@rm -rf $(TARGET_DIR)
	@rm -rf $(ROOT_DIR)/.cargo

# ==== Installation ====

.PHONY: install
install: $(DISK_QCOW2) ## Install to system
	@echo "[INSTALL] Installing Mach_R..."
	@sudo mkdir -p /opt/mach_r
	@sudo cp $(DISK_QCOW2) /opt/mach_r/
	@sudo cp $(KERNEL_BIN) /opt/mach_r/
	@echo "[INSTALL] Installed to /opt/mach_r"

.PHONY: uninstall
uninstall: ## Uninstall from system
	@echo "[UNINSTALL] Removing Mach_R..."
	@sudo rm -rf /opt/mach_r

# ==== Dependencies ====

.PHONY: deps
deps: ## Install build dependencies
	@echo "[DEPS] Installing dependencies..."
	@if [[ "$$(uname)" == "Darwin" ]]; then \
		echo "[DEPS] Installing macOS dependencies..."; \
		command -v brew >/dev/null || /bin/bash -c "$$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"; \
		brew install qemu coreutils gnu-sed gawk binutils; \
		brew install --cask utm; \
	else \
		echo "[DEPS] Installing Linux dependencies..."; \
		sudo apt-get update; \
		sudo apt-get install -y qemu-system build-essential \
			parted dosfstools mtools xorriso grub-pc-bin grub-efi-amd64-bin; \
	fi
	@$(RUSTUP) target add $(RUST_TARGET)
	@$(RUSTUP) component add rust-src llvm-tools-preview

# ==== CI/CD ====

.PHONY: ci
ci: lint test kernel ## Run CI checks

.PHONY: release
release: ## Create release artifacts
	@echo "[RELEASE] Creating release v$(VERSION)..."
	@mkdir -p $(DIST_DIR)/release
	@cp $(DISK_QCOW2) $(DIST_DIR)/release/mach_r-$(VERSION).qcow2
	@cp $(DISK_VMDK) $(DIST_DIR)/release/mach_r-$(VERSION).vmdk
	@cp $(ISO_IMAGE) $(DIST_DIR)/release/mach_r-$(VERSION).iso
	@tar -czf $(DIST_DIR)/release/mach_r-$(VERSION).tar.gz \
		-C $(DIST_DIR)/release .
	@echo "[RELEASE] Release artifacts in $(DIST_DIR)/release"

# ==== Statistics ====

.PHONY: stats
stats: ## Show project statistics
	@echo "[STATS] Project Statistics"
	@echo "=========================="
	@echo "Lines of Rust code:"
	@find src -name "*.rs" | xargs wc -l | tail -1
	@echo ""
	@echo "Binary sizes:"
	@ls -lh $(KERNEL_BIN) 2>/dev/null || echo "Kernel not built"
	@ls -lh $(DISK_QCOW2) 2>/dev/null || echo "Disk image not built"
	@echo ""
	@echo "Modules:"
	@find src -type f -name "*.rs" | wc -l

# Force rebuild
FORCE:

.PHONY: FORCE