//! Type-safe Rust stub generation for Mach IPC
//!
//! Generates idiomatic Rust code with:
//! - Zero-copy message serialization
//! - Type-safe IPC with compile-time guarantees
//! - Async-first API (optional)
//! - Comprehensive error handling

use crate::semantic::{AnalyzedSubsystem, AnalyzedRoutine};
use crate::parser::ast::Direction;
use crate::error::CodegenError;

pub struct RustStubGenerator {
    /// Generate async stubs (requires tokio)
    pub async_api: bool,
    /// Generate server traits
    pub server_traits: bool,
    /// Use repr(C) for all message types
    pub repr_c: bool,
}

impl RustStubGenerator {
    pub fn new() -> Self {
        Self {
            async_api: false,
            server_traits: false,
            repr_c: true,
        }
    }

    pub fn with_async(mut self) -> Self {
        self.async_api = true;
        self
    }

    pub fn with_server_traits(mut self) -> Self {
        self.server_traits = true;
        self
    }

    /// Generate complete Rust module
    pub fn generate(&self, analyzed: &AnalyzedSubsystem) -> Result<String, CodegenError> {
        let mut output = String::new();

        // File header
        output.push_str(&self.generate_header(analyzed)?);

        // Module declaration
        output.push_str(&format!("pub mod {} {{\n", analyzed.name));
        output.push_str("    use super::*;\n\n");

        // Constants
        output.push_str(&self.generate_constants(analyzed)?);

        // Message type definitions
        for routine in &analyzed.routines {
            output.push_str(&self.generate_message_types(routine, analyzed)?);
        }

        // Client stubs
        output.push_str(&self.generate_client_stubs(analyzed)?);

        // Server traits (optional)
        if self.server_traits {
            output.push_str(&self.generate_server_traits(analyzed)?);
        }

        output.push_str("}\n");

        Ok(output)
    }

    /// Generate file header with imports
    fn generate_header(&self, analyzed: &AnalyzedSubsystem) -> Result<String, CodegenError> {
        let mut output = String::new();

        output.push_str(&format!("//! Generated by mig-rust from {}.defs\n", analyzed.name));
        output.push_str("//!\n");
        output.push_str("//! This module provides type-safe Rust bindings for Mach IPC.\n");
        output.push_str("//! All message structures use zero-copy serialization where possible.\n");
        output.push_str("#![allow(dead_code, non_camel_case_types, non_snake_case)]\n\n");

        // Core imports
        output.push_str("use std::mem::size_of;\n");
        output.push_str("use std::marker::PhantomData;\n\n");

        // Runtime imports (from mach_r crate)
        output.push_str("// Runtime types from mach_r crate\n");
        output.push_str("use mach_r::ipc::{\n");
        output.push_str("    MachMsgHeader, MachMsgType, PortName,\n");
        output.push_str("    IpcError, KernReturn,\n");
        output.push_str("    MACH_MSGH_BITS, MACH_MSGH_BITS_REMOTE,\n");
        output.push_str("    MACH_MSG_TYPE_COPY_SEND, MACH_MSG_TYPE_MAKE_SEND_ONCE,\n");
        output.push_str("    MACH_MSG_TYPE_INTEGER_32, MACH_MSG_TYPE_INTEGER_64,\n");
        output.push_str("    MACH_PORT_NULL, KERN_SUCCESS,\n");
        output.push_str("    MACH_MSG_TIMEOUT_NONE,\n");
        output.push_str("    send_msg, recv_msg, send_recv_msg,\n");
        output.push_str("};\n\n");

        if self.async_api {
            output.push_str("use mach_r::ipc::AsyncPort;\n");
            output.push_str("use async_trait::async_trait;\n\n");
        }

        Ok(output)
    }

    /// Generate subsystem constants
    fn generate_constants(&self, analyzed: &AnalyzedSubsystem) -> Result<String, CodegenError> {
        let mut output = String::new();

        output.push_str("    // ════════════════════════════════════════════════════════════\n");
        output.push_str("    // Constants\n");
        output.push_str("    // ════════════════════════════════════════════════════════════\n\n");

        output.push_str(&format!("    /// Subsystem base message ID\n"));
        output.push_str(&format!("    pub const BASE_ID: u32 = {};\n\n", analyzed.base));

        for routine in &analyzed.routines {
            output.push_str(&format!("    /// Message ID for {}\n", routine.name));
            output.push_str(&format!("    pub const {}_ID: u32 = {};\n",
                routine.name.to_uppercase(), routine.number));
        }

        output.push_str("\n");
        Ok(output)
    }

    /// Generate message type definitions for a routine
    fn generate_message_types(&self, routine: &AnalyzedRoutine, _subsystem: &AnalyzedSubsystem) -> Result<String, CodegenError> {
        let mut output = String::new();

        output.push_str("    // ════════════════════════════════════════════════════════════\n");
        output.push_str(&format!("    // Messages for {}\n", routine.name));
        output.push_str("    // ════════════════════════════════════════════════════════════\n\n");

        // Request message
        output.push_str(&self.generate_request_type(routine)?);

        // Reply message (if not simpleroutine)
        if !routine.is_simple {
            output.push_str(&self.generate_reply_type(routine)?);
        }

        Ok(output)
    }

    /// Generate request message struct
    fn generate_request_type(&self, routine: &AnalyzedRoutine) -> Result<String, CodegenError> {
        let mut output = String::new();

        let struct_name = format!("{}Request", to_camel_case(&routine.name));

        // Documentation
        output.push_str(&format!("    /// Request message for {}\n", routine.name));
        output.push_str(&format!("    #[repr(C, align(8))]\n"));
        output.push_str(&format!("    #[derive(Copy, Clone)]\n"));
        output.push_str(&format!("    pub struct {} {{\n", struct_name));

        // Message header
        output.push_str("        pub header: MachMsgHeader,\n\n");

        // Generate fields from layout
        for field in &routine.request_layout.fields {
            if field.is_type_descriptor {
                output.push_str(&format!("        /// Type descriptor for {}\n",
                    field.name.strip_suffix("Type").unwrap_or(&field.name)));
                output.push_str(&format!("        pub {}: MachMsgType,\n", field.name));
            } else if field.is_count_field {
                output.push_str(&format!("        /// Array count for {}\n",
                    field.name.strip_suffix("Cnt").unwrap_or(&field.name)));
                output.push_str(&format!("        pub {}: u32,\n", field.name));
            } else if field.is_array {
                let elem_type = field.c_type.trim_end_matches('*').trim();
                let rust_type = c_type_to_rust(elem_type);
                if let Some(max) = field.max_array_elements {
                    output.push_str(&format!("        /// Array data (max {} elements)\n", max));
                    output.push_str(&format!("        pub {}: [{}; {}],\n", field.name, rust_type, max));
                } else {
                    output.push_str(&format!("        /// Array pointer\n"));
                    output.push_str(&format!("        pub {}: *const {},\n", field.name, rust_type));
                }
            } else {
                let rust_type = c_type_to_rust(&field.c_type);
                output.push_str(&format!("        pub {}: {},\n", field.name, rust_type));
            }
        }

        output.push_str("    }\n\n");

        // Constructor
        output.push_str(&self.generate_request_constructor(routine, &struct_name)?);

        Ok(output)
    }

    /// Generate request constructor
    fn generate_request_constructor(&self, routine: &AnalyzedRoutine, struct_name: &str) -> Result<String, CodegenError> {
        let mut output = String::new();

        output.push_str(&format!("    impl {} {{\n", struct_name));
        output.push_str("        /// Create a new request message\n");
        output.push_str("        pub fn new(\n");

        // Parameters
        for arg in &routine.routine.args {
            let is_array = routine.request_layout.fields.iter()
                .any(|f| f.name == arg.name && f.is_array);

            if matches!(arg.direction, Direction::In | Direction::InOut | Direction::RequestPort) {
                let param_type = if is_array {
                    let field = routine.request_layout.fields.iter()
                        .find(|f| f.name == arg.name && f.is_array)
                        .unwrap();
                    let elem_type = field.c_type.trim_end_matches('*').trim();
                    let rust_type = c_type_to_rust(elem_type);
                    format!("&[{}]", rust_type)
                } else {
                    let field = routine.request_layout.fields.iter()
                        .find(|f| f.name == arg.name && !f.is_type_descriptor)
                        .unwrap();
                    c_type_to_rust(&field.c_type)
                };

                output.push_str(&format!("            {}: {},\n", arg.name, param_type));
            }
        }

        output.push_str("        ) -> Result<Self, IpcError> {\n");

        // Validation for arrays
        for field in &routine.request_layout.fields {
            if field.is_array {
                if let Some(max) = field.max_array_elements {
                    output.push_str(&format!("            if {}.len() > {} {{\n", field.name, max));
                    output.push_str("                return Err(IpcError::ArrayTooLarge {\n");
                    output.push_str(&format!("                    actual: {}.len(),\n", field.name));
                    output.push_str(&format!("                    max: {},\n", max));
                    output.push_str("                });\n");
                    output.push_str("            }\n\n");
                }
            }
        }

        // Initialize message structure
        output.push_str("            let mut msg = Self {\n");
        output.push_str("                header: MachMsgHeader::new(\n");
        output.push_str(&format!("                    {}_ID,\n", routine.name.to_uppercase()));
        output.push_str(&format!("                    size_of::<Self>() as u32,\n"));
        output.push_str("                ),\n");

        // Initialize all fields
        for field in &routine.request_layout.fields {
            if field.is_type_descriptor {
                // Type descriptor initialization
                let base_name = field.name.strip_suffix("Type").unwrap_or(&field.name);

                // Look at the actual data field to determine type
                let data_field = routine.request_layout.fields.iter()
                    .find(|f| f.name == base_name);

                if let Some(df) = data_field {
                    // Check if it's a port type by examining the c_type
                    if df.c_type.contains("mach_port") || df.c_type == "PortName" {
                        output.push_str(&format!("                {}: MachMsgType::port_copy_send(),\n", field.name));
                    } else if df.c_type.contains("int64") {
                        output.push_str(&format!("                {}: MachMsgType::integer_64(1),\n", field.name));
                    } else {
                        output.push_str(&format!("                {}: MachMsgType::integer_32(1),\n", field.name));
                    }
                } else {
                    // Fallback: default to integer_32
                    output.push_str(&format!("                {}: MachMsgType::integer_32(1),\n", field.name));
                }
            } else if field.is_count_field {
                // Count field - set to array length
                let array_name = field.name.strip_suffix("Cnt").unwrap_or(&field.name);
                output.push_str(&format!("                {}: {}.len() as u32,\n", field.name, array_name));
            } else if field.is_array {
                // Array field - initialize based on type
                if let Some(max) = field.max_array_elements {
                    // Fixed-size array - copy data
                    output.push_str(&format!("                {}: {{\n", field.name));
                    output.push_str(&format!("                    let mut arr = [Default::default(); {}];\n", max));
                    output.push_str(&format!("                    arr[..{}.len()].copy_from_slice({});\n", field.name, field.name));
                    output.push_str("                    arr\n");
                    output.push_str("                },\n");
                } else {
                    // Pointer - just store the pointer
                    output.push_str(&format!("                {}: {}.as_ptr(),\n", field.name, field.name));
                }
            } else {
                // Regular field - just copy the value
                output.push_str(&format!("                {}: {},\n", field.name, field.name));
            }
        }

        output.push_str("            };\n\n");

        // Update type descriptor counts for arrays
        for field in &routine.request_layout.fields {
            if field.is_array {
                let type_field_name = format!("{}Type", field.name);
                output.push_str(&format!("            msg.{}.msgt_number = {}.len() as u32;\n",
                    type_field_name, field.name));
            }
        }

        output.push_str("\n            Ok(msg)\n");
        output.push_str("        }\n");
        output.push_str("    }\n\n");

        Ok(output)
    }

    /// Generate reply message struct
    fn generate_reply_type(&self, routine: &AnalyzedRoutine) -> Result<String, CodegenError> {
        let mut output = String::new();

        if let Some(ref reply_layout) = routine.reply_layout {
            let struct_name = format!("{}Reply", to_camel_case(&routine.name));

            output.push_str(&format!("    /// Reply message for {}\n", routine.name));
            output.push_str("    #[repr(C, align(8))]\n");
            output.push_str("    #[derive(Copy, Clone)]\n");
            output.push_str(&format!("    pub struct {} {{\n", struct_name));

            output.push_str("        pub header: MachMsgHeader,\n");

            for field in &reply_layout.fields {
                if field.is_type_descriptor {
                    output.push_str(&format!("        pub {}: MachMsgType,\n", field.name));
                } else {
                    let rust_type = c_type_to_rust(&field.c_type);
                    output.push_str(&format!("        pub {}: {},\n", field.name, rust_type));
                }
            }

            output.push_str("    }\n\n");
        }

        Ok(output)
    }

    /// Generate client stub functions
    fn generate_client_stubs(&self, analyzed: &AnalyzedSubsystem) -> Result<String, CodegenError> {
        let mut output = String::new();

        output.push_str("    // ════════════════════════════════════════════════════════════\n");
        output.push_str("    // Client Stubs\n");
        output.push_str("    // ════════════════════════════════════════════════════════════\n\n");

        for routine in &analyzed.routines {
            output.push_str(&self.generate_client_stub(routine)?);
        }

        Ok(output)
    }

    /// Generate single client stub
    fn generate_client_stub(&self, routine: &AnalyzedRoutine) -> Result<String, CodegenError> {
        let mut output = String::new();

        // Synchronous version
        output.push_str(&format!("    /// {} (synchronous)\n", routine.name));
        output.push_str(&format!("    pub fn {}(\n", routine.name));

        // Parameters
        output.push_str("        port: PortName,\n");

        // Collect parameters and return values
        let mut params = Vec::new();
        let mut returns = Vec::new();

        for arg in &routine.routine.args {
            let is_array = routine.request_layout.fields.iter()
                .any(|f| f.name == arg.name && f.is_array);

            match arg.direction {
                Direction::In | Direction::InOut | Direction::RequestPort => {
                    let param_type = if is_array {
                        let field = routine.request_layout.fields.iter()
                            .find(|f| f.name == arg.name && f.is_array)
                            .unwrap();
                        let elem_type = field.c_type.trim_end_matches('*').trim();
                        let rust_type = c_type_to_rust(elem_type);
                        format!("&[{}]", rust_type)
                    } else {
                        let field = routine.request_layout.fields.iter()
                            .find(|f| f.name == arg.name && !f.is_type_descriptor && !f.is_count_field);

                        if let Some(f) = field {
                            c_type_to_rust(&f.c_type)
                        } else {
                            "i32".to_string() // Default fallback
                        }
                    };

                    params.push((arg.name.clone(), param_type.clone()));
                    output.push_str(&format!("        {}: {},\n", arg.name, param_type));
                }
                Direction::Out => {
                    if let Some(reply_layout) = &routine.reply_layout {
                        let field = reply_layout.fields.iter()
                            .find(|f| f.name == arg.name && !f.is_type_descriptor && !f.is_count_field);

                        if let Some(f) = field {
                            let rust_type = c_type_to_rust(&f.c_type);
                            returns.push((arg.name.clone(), rust_type));
                        }
                    }
                }
                _ => {}
            }
        }

        output.push_str("    ) -> Result<");

        // Return type
        if routine.is_simple {
            output.push_str("(), IpcError> {\n");
        } else {
            if returns.is_empty() {
                output.push_str("(), IpcError> {\n");
            } else if returns.len() == 1 {
                output.push_str(&format!("{}, IpcError> {{\n", returns[0].1));
            } else {
                let return_types: Vec<String> = returns.iter().map(|(_, ty)| ty.clone()).collect();
                output.push_str(&format!("({}), IpcError> {{\n", return_types.join(", ")));
            }
        }

        // Implementation
        let request_struct = format!("{}Request", to_camel_case(&routine.name));

        output.push_str("        // Create request message\n");
        output.push_str(&format!("        let mut request = {}::new(", request_struct));

        // Pass constructor arguments
        let param_names: Vec<String> = params.iter().map(|(name, _)| name.clone()).collect();
        output.push_str(&param_names.join(", "));
        output.push_str(")?;\n\n");

        if routine.is_simple {
            // Simple routine - send only, no reply
            output.push_str("        // Set destination port\n");
            output.push_str("        request.header = request.header\n");
            output.push_str("            .with_remote_port(port, MACH_MSG_TYPE_COPY_SEND as u32)\n");
            output.push_str("            .with_bits(MACH_MSGH_BITS(\n");
            output.push_str("                MACH_MSG_TYPE_COPY_SEND as u32,\n");
            output.push_str("                0,\n");
            output.push_str("            ));\n\n");

            output.push_str("        // Send message\n");
            output.push_str("        unsafe {\n");
            output.push_str("            send_msg(\n");
            output.push_str("                &mut request.header as *mut _,\n");
            output.push_str("                size_of::<");
            output.push_str(&request_struct);
            output.push_str(">() as u32,\n");
            output.push_str("                MACH_MSG_TIMEOUT_NONE,\n");
            output.push_str("            )\n");
            output.push_str("        }\n");
        } else {
            // Normal routine - send and receive reply
            let reply_struct = format!("{}Reply", to_camel_case(&routine.name));

            output.push_str("        // Allocate reply buffer\n");
            output.push_str(&format!("        let mut reply: {} = unsafe {{ std::mem::zeroed() }};\n\n", reply_struct));

            output.push_str("        // Set destination and reply ports\n");
            output.push_str("        request.header = request.header\n");
            output.push_str("            .with_remote_port(port, MACH_MSG_TYPE_COPY_SEND as u32)\n");
            output.push_str("            .with_bits(MACH_MSGH_BITS(\n");
            output.push_str("                MACH_MSG_TYPE_COPY_SEND as u32,\n");
            output.push_str("                MACH_MSG_TYPE_MAKE_SEND_ONCE as u32,\n");
            output.push_str("            ));\n\n");

            output.push_str("        // Send request and receive reply\n");
            output.push_str("        unsafe {\n");
            output.push_str("            send_recv_msg(\n");
            output.push_str("                &mut request.header as *mut _,\n");
            output.push_str("                size_of::<");
            output.push_str(&request_struct);
            output.push_str(">() as u32,\n");
            output.push_str("                size_of::<");
            output.push_str(&reply_struct);
            output.push_str(">() as u32,\n");
            output.push_str("                MACH_PORT_NULL,\n");
            output.push_str("                MACH_MSG_TIMEOUT_NONE,\n");
            output.push_str("            )?;\n");
            output.push_str("        }\n\n");

            output.push_str("        // Check return code\n");
            output.push_str("        reply.RetCode.to_result()?;\n\n");

            // Extract return values
            if !returns.is_empty() {
                output.push_str("        // Extract return values\n");
                if returns.len() == 1 {
                    output.push_str(&format!("        Ok(reply.{})\n", returns[0].0));
                } else {
                    let return_exprs: Vec<String> = returns.iter()
                        .map(|(name, _)| format!("reply.{}", name))
                        .collect();
                    output.push_str(&format!("        Ok(({}))\n", return_exprs.join(", ")));
                }
            } else {
                output.push_str("        Ok(())\n");
            }
        }

        output.push_str("    }\n\n");

        // Async version
        if self.async_api {
            output.push_str(&format!("    /// {} (asynchronous)\n", routine.name));
            output.push_str(&format!("    pub async fn {}_async(\n", routine.name));
            output.push_str("        port: &AsyncPort,\n");
            output.push_str("    ) -> Result<(), IpcError> {\n");
            output.push_str("        // TODO: Async implementation\n");
            output.push_str("        unimplemented!()\n");
            output.push_str("    }\n\n");
        }

        Ok(output)
    }

    /// Generate server traits
    fn generate_server_traits(&self, analyzed: &AnalyzedSubsystem) -> Result<String, CodegenError> {
        let mut output = String::new();

        output.push_str("    // ════════════════════════════════════════════════════════════\n");
        output.push_str("    // Server Traits\n");
        output.push_str("    // ════════════════════════════════════════════════════════════\n\n");

        let trait_name = format!("{}Server", to_camel_case(&analyzed.name));

        if self.async_api {
            output.push_str("    #[async_trait]\n");
        }

        output.push_str(&format!("    pub trait {}: Send + Sync {{\n", trait_name));

        for routine in &analyzed.routines {
            output.push_str(&format!("        /// Implementation of {}\n", routine.name));

            if self.async_api {
                output.push_str(&format!("        async fn {}(&self) -> Result<(), IpcError>;\n", routine.name));
            } else {
                output.push_str(&format!("        fn {}(&self) -> Result<(), IpcError>;\n", routine.name));
            }
        }

        output.push_str("    }\n\n");

        Ok(output)
    }
}

impl Default for RustStubGenerator {
    fn default() -> Self {
        Self::new()
    }
}

/// Convert snake_case to CamelCase
fn to_camel_case(s: &str) -> String {
    s.split('_')
        .map(|word| {
            let mut chars = word.chars();
            match chars.next() {
                Some(c) => c.to_uppercase().chain(chars).collect(),
                None => String::new(),
            }
        })
        .collect()
}

/// Convert C type to Rust type
fn c_type_to_rust(c_type: &str) -> String {
    match c_type.trim() {
        "int32_t" => "i32".to_string(),
        "int64_t" => "i64".to_string(),
        "uint32_t" => "u32".to_string(),
        "uint64_t" => "u64".to_string(),
        "mach_port_t" => "PortName".to_string(),
        "kern_return_t" => "KernReturn".to_string(),
        "boolean_t" => "bool".to_string(),
        other => other.to_string(),
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_camel_case() {
        assert_eq!(to_camel_case("sum_array"), "SumArray");
        assert_eq!(to_camel_case("hello_world"), "HelloWorld");
        assert_eq!(to_camel_case("test"), "Test");
    }

    #[test]
    fn test_c_to_rust_types() {
        assert_eq!(c_type_to_rust("int32_t"), "i32");
        assert_eq!(c_type_to_rust("mach_port_t"), "PortName");
    }
}
