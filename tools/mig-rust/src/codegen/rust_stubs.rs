//! Type-safe Rust stub generation for Mach IPC
//!
//! Generates idiomatic Rust code with:
//! - Zero-copy message serialization
//! - Type-safe IPC with compile-time guarantees
//! - Async-first API (optional)
//! - Comprehensive error handling

use crate::semantic::{AnalyzedSubsystem, AnalyzedRoutine};
use crate::parser::ast::Direction;
use crate::error::CodegenError;

pub struct RustStubGenerator {
    /// Generate async stubs (requires tokio)
    pub async_api: bool,
    /// Generate server traits
    pub server_traits: bool,
    /// Use repr(C) for all message types
    pub repr_c: bool,
}

impl RustStubGenerator {
    pub fn new() -> Self {
        Self {
            async_api: false,
            server_traits: false,
            repr_c: true,
        }
    }

    pub fn with_async(mut self) -> Self {
        self.async_api = true;
        self
    }

    pub fn with_server_traits(mut self) -> Self {
        self.server_traits = true;
        self
    }

    /// Generate complete Rust module
    pub fn generate(&self, analyzed: &AnalyzedSubsystem) -> Result<String, CodegenError> {
        let mut output = String::new();

        // File header
        output.push_str(&self.generate_header(analyzed)?);

        // Module declaration
        output.push_str(&format!("pub mod {} {{\n", analyzed.name));
        output.push_str("    use super::*;\n\n");

        // Constants
        output.push_str(&self.generate_constants(analyzed)?);

        // Message type definitions
        for routine in &analyzed.routines {
            output.push_str(&self.generate_message_types(routine, analyzed)?);
        }

        // Client stubs
        output.push_str(&self.generate_client_stubs(analyzed)?);

        // Server traits (optional)
        if self.server_traits {
            output.push_str(&self.generate_server_traits(analyzed)?);
        }

        output.push_str("}\n");

        Ok(output)
    }

    /// Generate file header with imports
    fn generate_header(&self, analyzed: &AnalyzedSubsystem) -> Result<String, CodegenError> {
        let mut output = String::new();

        output.push_str(&format!("//! Generated by mig-rust from {}.defs\n", analyzed.name));
        output.push_str("//!\n");
        output.push_str("//! This module provides type-safe Rust bindings for Mach IPC.\n");
        output.push_str("//! All message structures use zero-copy serialization where possible.\n");
        output.push_str("#![allow(dead_code, non_camel_case_types, non_snake_case)]\n\n");

        // Core imports
        output.push_str("use std::mem::size_of;\n");
        output.push_str("use std::marker::PhantomData;\n\n");

        // Runtime imports (from mach_r crate)
        output.push_str("// Runtime types from mach_r crate\n");
        output.push_str("use mach_r::ipc::{\n");
        output.push_str("    MachMsgHeader, MachMsgType, PortName,\n");
        output.push_str("    IpcError, KernReturn,\n");
        output.push_str("    MACH_MSGH_BITS, MACH_MSGH_BITS_REMOTE,\n");
        output.push_str("    MACH_MSG_TYPE_COPY_SEND, MACH_MSG_TYPE_MAKE_SEND_ONCE,\n");
        output.push_str("    MACH_MSG_TYPE_INTEGER_32, MACH_MSG_TYPE_INTEGER_64,\n");
        output.push_str("    MACH_PORT_NULL, KERN_SUCCESS,\n");
        output.push_str("};\n\n");

        if self.async_api {
            output.push_str("use mach_r::ipc::AsyncPort;\n");
            output.push_str("use async_trait::async_trait;\n\n");
        }

        Ok(output)
    }

    /// Generate subsystem constants
    fn generate_constants(&self, analyzed: &AnalyzedSubsystem) -> Result<String, CodegenError> {
        let mut output = String::new();

        output.push_str("    // ════════════════════════════════════════════════════════════\n");
        output.push_str("    // Constants\n");
        output.push_str("    // ════════════════════════════════════════════════════════════\n\n");

        output.push_str(&format!("    /// Subsystem base message ID\n"));
        output.push_str(&format!("    pub const BASE_ID: u32 = {};\n\n", analyzed.base));

        for routine in &analyzed.routines {
            output.push_str(&format!("    /// Message ID for {}\n", routine.name));
            output.push_str(&format!("    pub const {}_ID: u32 = {};\n",
                routine.name.to_uppercase(), routine.number));
        }

        output.push_str("\n");
        Ok(output)
    }

    /// Generate message type definitions for a routine
    fn generate_message_types(&self, routine: &AnalyzedRoutine, _subsystem: &AnalyzedSubsystem) -> Result<String, CodegenError> {
        let mut output = String::new();

        output.push_str("    // ════════════════════════════════════════════════════════════\n");
        output.push_str(&format!("    // Messages for {}\n", routine.name));
        output.push_str("    // ════════════════════════════════════════════════════════════\n\n");

        // Request message
        output.push_str(&self.generate_request_type(routine)?);

        // Reply message (if not simpleroutine)
        if !routine.is_simple {
            output.push_str(&self.generate_reply_type(routine)?);
        }

        Ok(output)
    }

    /// Generate request message struct
    fn generate_request_type(&self, routine: &AnalyzedRoutine) -> Result<String, CodegenError> {
        let mut output = String::new();

        let struct_name = format!("{}Request", to_camel_case(&routine.name));

        // Documentation
        output.push_str(&format!("    /// Request message for {}\n", routine.name));
        output.push_str(&format!("    #[repr(C, align(8))]\n"));
        output.push_str(&format!("    #[derive(Copy, Clone)]\n"));
        output.push_str(&format!("    pub struct {} {{\n", struct_name));

        // Message header
        output.push_str("        pub header: MachMsgHeader,\n\n");

        // Generate fields from layout
        for field in &routine.request_layout.fields {
            if field.is_type_descriptor {
                output.push_str(&format!("        /// Type descriptor for {}\n",
                    field.name.strip_suffix("Type").unwrap_or(&field.name)));
                output.push_str(&format!("        pub {}: MachMsgType,\n", field.name));
            } else if field.is_count_field {
                output.push_str(&format!("        /// Array count for {}\n",
                    field.name.strip_suffix("Cnt").unwrap_or(&field.name)));
                output.push_str(&format!("        pub {}: u32,\n", field.name));
            } else if field.is_array {
                let elem_type = field.c_type.trim_end_matches('*').trim();
                let rust_type = c_type_to_rust(elem_type);
                if let Some(max) = field.max_array_elements {
                    output.push_str(&format!("        /// Array data (max {} elements)\n", max));
                    output.push_str(&format!("        pub {}: [{}; {}],\n", field.name, rust_type, max));
                } else {
                    output.push_str(&format!("        /// Array pointer\n"));
                    output.push_str(&format!("        pub {}: *const {},\n", field.name, rust_type));
                }
            } else {
                let rust_type = c_type_to_rust(&field.c_type);
                output.push_str(&format!("        pub {}: {},\n", field.name, rust_type));
            }
        }

        output.push_str("    }\n\n");

        // Constructor
        output.push_str(&self.generate_request_constructor(routine, &struct_name)?);

        Ok(output)
    }

    /// Generate request constructor
    fn generate_request_constructor(&self, routine: &AnalyzedRoutine, struct_name: &str) -> Result<String, CodegenError> {
        let mut output = String::new();

        output.push_str(&format!("    impl {} {{\n", struct_name));
        output.push_str("        /// Create a new request message\n");
        output.push_str("        pub fn new(\n");

        // Parameters
        for arg in &routine.routine.args {
            let is_array = routine.request_layout.fields.iter()
                .any(|f| f.name == arg.name && f.is_array);

            if matches!(arg.direction, Direction::In | Direction::InOut | Direction::RequestPort) {
                let param_type = if is_array {
                    let field = routine.request_layout.fields.iter()
                        .find(|f| f.name == arg.name && f.is_array)
                        .unwrap();
                    let elem_type = field.c_type.trim_end_matches('*').trim();
                    let rust_type = c_type_to_rust(elem_type);
                    format!("&[{}]", rust_type)
                } else {
                    let field = routine.request_layout.fields.iter()
                        .find(|f| f.name == arg.name && !f.is_type_descriptor)
                        .unwrap();
                    c_type_to_rust(&field.c_type)
                };

                output.push_str(&format!("            {}: {},\n", arg.name, param_type));
            }
        }

        output.push_str("        ) -> Result<Self, IpcError> {\n");

        // Validation for arrays
        for field in &routine.request_layout.fields {
            if field.is_array {
                if let Some(max) = field.max_array_elements {
                    output.push_str(&format!("            if {}.len() > {} {{\n", field.name, max));
                    output.push_str("                return Err(IpcError::ArrayTooLarge {\n");
                    output.push_str(&format!("                    actual: {}.len(),\n", field.name));
                    output.push_str(&format!("                    max: {},\n", max));
                    output.push_str("                });\n");
                    output.push_str("            }\n\n");
                }
            }
        }

        output.push_str("            let mut msg = Self {\n");
        output.push_str("                header: MachMsgHeader::new(\n");
        output.push_str(&format!("                    {}_ID,\n", routine.name.to_uppercase()));
        output.push_str("                    0,  // size computed below\n");
        output.push_str("                ),\n");

        // Initialize fields
        output.push_str("                // TODO: Initialize fields\n");

        output.push_str("            };\n\n");

        output.push_str("            Ok(msg)\n");
        output.push_str("        }\n");
        output.push_str("    }\n\n");

        Ok(output)
    }

    /// Generate reply message struct
    fn generate_reply_type(&self, routine: &AnalyzedRoutine) -> Result<String, CodegenError> {
        let mut output = String::new();

        if let Some(ref reply_layout) = routine.reply_layout {
            let struct_name = format!("{}Reply", to_camel_case(&routine.name));

            output.push_str(&format!("    /// Reply message for {}\n", routine.name));
            output.push_str("    #[repr(C, align(8))]\n");
            output.push_str("    #[derive(Copy, Clone)]\n");
            output.push_str(&format!("    pub struct {} {{\n", struct_name));

            output.push_str("        pub header: MachMsgHeader,\n");

            for field in &reply_layout.fields {
                if field.is_type_descriptor {
                    output.push_str(&format!("        pub {}: MachMsgType,\n", field.name));
                } else {
                    let rust_type = c_type_to_rust(&field.c_type);
                    output.push_str(&format!("        pub {}: {},\n", field.name, rust_type));
                }
            }

            output.push_str("    }\n\n");
        }

        Ok(output)
    }

    /// Generate client stub functions
    fn generate_client_stubs(&self, analyzed: &AnalyzedSubsystem) -> Result<String, CodegenError> {
        let mut output = String::new();

        output.push_str("    // ════════════════════════════════════════════════════════════\n");
        output.push_str("    // Client Stubs\n");
        output.push_str("    // ════════════════════════════════════════════════════════════\n\n");

        for routine in &analyzed.routines {
            output.push_str(&self.generate_client_stub(routine)?);
        }

        Ok(output)
    }

    /// Generate single client stub
    fn generate_client_stub(&self, routine: &AnalyzedRoutine) -> Result<String, CodegenError> {
        let mut output = String::new();

        // Synchronous version
        output.push_str(&format!("    /// {} (synchronous)\n", routine.name));
        output.push_str(&format!("    pub fn {}(\n", routine.name));

        // Parameters
        output.push_str("        port: PortName,\n");
        for arg in &routine.routine.args {
            if matches!(arg.direction, Direction::In | Direction::InOut) {
                output.push_str(&format!("        {}: /* TODO */,\n", arg.name));
            }
        }

        output.push_str("    ) -> Result<");

        // Return type
        if routine.is_simple {
            output.push_str("(), IpcError> {\n");
        } else {
            output.push_str("(/* TODO: return types */), IpcError> {\n");
        }

        output.push_str("        // TODO: Implementation\n");
        output.push_str("        unimplemented!()\n");
        output.push_str("    }\n\n");

        // Async version
        if self.async_api {
            output.push_str(&format!("    /// {} (asynchronous)\n", routine.name));
            output.push_str(&format!("    pub async fn {}_async(\n", routine.name));
            output.push_str("        port: &AsyncPort,\n");
            output.push_str("    ) -> Result<(), IpcError> {\n");
            output.push_str("        // TODO: Async implementation\n");
            output.push_str("        unimplemented!()\n");
            output.push_str("    }\n\n");
        }

        Ok(output)
    }

    /// Generate server traits
    fn generate_server_traits(&self, analyzed: &AnalyzedSubsystem) -> Result<String, CodegenError> {
        let mut output = String::new();

        output.push_str("    // ════════════════════════════════════════════════════════════\n");
        output.push_str("    // Server Traits\n");
        output.push_str("    // ════════════════════════════════════════════════════════════\n\n");

        let trait_name = format!("{}Server", to_camel_case(&analyzed.name));

        if self.async_api {
            output.push_str("    #[async_trait]\n");
        }

        output.push_str(&format!("    pub trait {}: Send + Sync {{\n", trait_name));

        for routine in &analyzed.routines {
            output.push_str(&format!("        /// Implementation of {}\n", routine.name));

            if self.async_api {
                output.push_str(&format!("        async fn {}(&self) -> Result<(), IpcError>;\n", routine.name));
            } else {
                output.push_str(&format!("        fn {}(&self) -> Result<(), IpcError>;\n", routine.name));
            }
        }

        output.push_str("    }\n\n");

        Ok(output)
    }
}

impl Default for RustStubGenerator {
    fn default() -> Self {
        Self::new()
    }
}

/// Convert snake_case to CamelCase
fn to_camel_case(s: &str) -> String {
    s.split('_')
        .map(|word| {
            let mut chars = word.chars();
            match chars.next() {
                Some(c) => c.to_uppercase().chain(chars).collect(),
                None => String::new(),
            }
        })
        .collect()
}

/// Convert C type to Rust type
fn c_type_to_rust(c_type: &str) -> String {
    match c_type.trim() {
        "int32_t" => "i32".to_string(),
        "int64_t" => "i64".to_string(),
        "uint32_t" => "u32".to_string(),
        "uint64_t" => "u64".to_string(),
        "mach_port_t" => "PortName".to_string(),
        "kern_return_t" => "KernReturn".to_string(),
        "boolean_t" => "bool".to_string(),
        other => other.to_string(),
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_camel_case() {
        assert_eq!(to_camel_case("sum_array"), "SumArray");
        assert_eq!(to_camel_case("hello_world"), "HelloWorld");
        assert_eq!(to_camel_case("test"), "Test");
    }

    #[test]
    fn test_c_to_rust_types() {
        assert_eq!(c_type_to_rust("int32_t"), "i32");
        assert_eq!(c_type_to_rust("mach_port_t"), "PortName");
    }
}
