# Rust Code Generation Design: Type-Safe Mach IPC

## Vision: Zero-Copy, Type-Safe, Async Mach IPC in Rust

**Goal**: Generate idiomatic Rust code from .defs files that provides:
- **Zero-copy** message serialization
- **Type-safe** IPC with compile-time guarantees
- **Async-first** API using Tokio
- **Cross-platform** support (macOS, xnu-based systems)
- **No unsafe** in generated code

---

## Architecture Overview

```
┌─────────────┐
│  .defs file │
└──────┬──────┘
       │ parse + semantic analysis
       ↓
┌──────────────────┐
│  AnalyzedSubsys  │  (MessageLayout with resolved types)
└────────┬─────────┘
         │
    ┌────┴────┐
    │         │
    ↓         ↓
┌─────┐   ┌──────────┐
│  C  │   │   Rust   │  ← NEW!
└─────┘   └────┬─────┘
               │
          ┌────┴────┬────────┬─────────┐
          │         │        │         │
          ↓         ↓        ↓         ↓
    ┌─────────┐ ┌──────┐ ┌──────┐ ┌────────┐
    │ Messages│ │Client│ │Server│ │Traits  │
    │  (repr) │ │Stubs │ │Stubs │ │(async) │
    └─────────┘ └──────┘ └──────┘ └────────┘
```

---

## Phase 1: Type-Safe Message Structures

### Input (.defs)
```c
subsystem array_test 2000;

type int32_t = integer_32;
type int32_array_t = array[*:1024] of int32_t;

routine sum_array(
    server_port : mach_port_t;
    in  data : int32_array_t;
    out total : int32_t
);
```

### Generated Rust (Phase 1: Messages)

```rust
//! Generated by mig-rust from array_test.defs
#![allow(dead_code, non_camel_case_types)]

use mach_r::ipc::*;
use mach_r::types::*;

/// Subsystem: array_test (base: 2000)
pub mod array_test {
    use super::*;

    /// Message ID constants
    pub const BASE_ID: u32 = 2000;
    pub const SUM_ARRAY_ID: u32 = 2000;

    // ════════════════════════════════════════════════════════════
    // Request Messages (Client → Server)
    // ════════════════════════════════════════════════════════════

    /// Request message for sum_array (ID: 2000)
    #[repr(C, align(8))]
    pub struct SumArrayRequest {
        pub header: MachMsgHeader,

        // Type descriptor for server_port
        pub server_port_type: MachMsgType,
        pub server_port: PortName,

        // Type descriptor for data (array)
        pub data_type: MachMsgType,
        pub data_count: u32,
        // Inline array data follows
        pub data: [i32; 1024],
    }

    impl SumArrayRequest {
        /// Create a new request message
        pub fn new(
            server_port: PortName,
            data: &[i32],
        ) -> Result<Self, IpcError> {
            if data.len() > 1024 {
                return Err(IpcError::ArrayTooLarge {
                    actual: data.len(),
                    max: 1024,
                });
            }

            let mut msg = Self {
                header: MachMsgHeader {
                    bits: MACH_MSGH_BITS_COMPLEX
                        | MACH_MSGH_BITS(MACH_MSG_TYPE_COPY_SEND, MACH_MSG_TYPE_MAKE_SEND_ONCE),
                    size: Self::size_for_count(data.len()),
                    remote_port: server_port,
                    local_port: MACH_PORT_NULL,
                    voucher_port: MACH_PORT_NULL,
                    id: SUM_ARRAY_ID,
                },
                server_port_type: MachMsgType::new_port(MACH_MSG_TYPE_COPY_SEND),
                server_port,
                data_type: MachMsgType::new_array(MACH_MSG_TYPE_INTEGER_32, data.len() as u32),
                data_count: data.len() as u32,
                data: [0; 1024],
            };

            // Zero-copy into inline buffer
            msg.data[..data.len()].copy_from_slice(data);

            Ok(msg)
        }

        /// Calculate message size for given array count
        #[inline]
        pub const fn size_for_count(count: usize) -> u32 {
            (size_of::<MachMsgHeader>()
                + size_of::<MachMsgType>() * 2
                + size_of::<PortName>()
                + size_of::<u32>()
                + size_of::<i32>() * count) as u32
        }

        /// Get data slice (only valid portion)
        pub fn data_slice(&self) -> &[i32] {
            &self.data[..self.data_count as usize]
        }
    }

    // ════════════════════════════════════════════════════════════
    // Reply Messages (Server → Client)
    // ════════════════════════════════════════════════════════════

    /// Reply message for sum_array
    #[repr(C, align(8))]
    pub struct SumArrayReply {
        pub header: MachMsgHeader,
        pub retcode_type: MachMsgType,
        pub retcode: KernReturn,
        pub total_type: MachMsgType,
        pub total: i32,
    }

    impl SumArrayReply {
        /// Parse reply message
        pub fn parse(msg: &[u8]) -> Result<i32, IpcError> {
            if msg.len() < size_of::<Self>() {
                return Err(IpcError::MessageTooSmall);
            }

            // Safety: We verified size above
            let reply = unsafe {
                &*(msg.as_ptr() as *const SumArrayReply)
            };

            // Validate header
            if reply.header.id != SUM_ARRAY_ID + 100 {
                return Err(IpcError::WrongMessageId {
                    expected: SUM_ARRAY_ID + 100,
                    actual: reply.header.id,
                });
            }

            // Check return code
            reply.retcode.into_result()?;

            // Validate type descriptors
            reply.total_type.validate(
                MACH_MSG_TYPE_INTEGER_32,
                32,
                1,
            )?;

            Ok(reply.total)
        }
    }
}
```

---

## Phase 2: Type-Safe Client Stubs (Sync)

```rust
pub mod array_test {
    // ... (messages from above) ...

    // ════════════════════════════════════════════════════════════
    // Client Stubs (Synchronous)
    // ════════════════════════════════════════════════════════════

    /// Sum an array of integers (synchronous)
    pub fn sum_array(
        server_port: PortName,
        data: &[i32],
    ) -> Result<i32, IpcError> {
        // Create request
        let request = SumArrayRequest::new(server_port, data)?;

        // Allocate reply buffer
        let mut reply_buf = vec![0u8; 1024];

        // Send + receive (blocking)
        unsafe {
            mach_msg(
                &request as *const _ as *mut _,
                MACH_SEND_MSG | MACH_RCV_MSG,
                request.header.size,
                reply_buf.len() as u32,
                mig_get_reply_port(),
                MACH_MSG_TIMEOUT_NONE,
                MACH_PORT_NULL,
            ).into_result()?;
        }

        // Parse reply
        SumArrayReply::parse(&reply_buf)
    }
}
```

---

## Phase 3: Async Client Stubs (Tokio)

```rust
pub mod array_test {
    // ... (messages + sync stubs from above) ...

    // ════════════════════════════════════════════════════════════
    // Client Stubs (Asynchronous)
    // ════════════════════════════════════════════════════════════

    /// Sum an array of integers (async)
    pub async fn sum_array_async(
        port: &AsyncPort,
        data: &[i32],
    ) -> Result<i32, IpcError> {
        // Create request
        let request = SumArrayRequest::new(port.name(), data)?;

        // Send via async runtime
        let reply = port.send_recv(&request).await?;

        // Parse reply
        SumArrayReply::parse(&reply)
    }

    /// Builder pattern for complex calls
    pub struct SumArrayCall<'a> {
        port: &'a AsyncPort,
        data: &'a [i32],
        timeout: Option<Duration>,
    }

    impl<'a> SumArrayCall<'a> {
        pub fn new(port: &'a AsyncPort, data: &'a [i32]) -> Self {
            Self {
                port,
                data,
                timeout: None,
            }
        }

        pub fn with_timeout(mut self, timeout: Duration) -> Self {
            self.timeout = Some(timeout);
            self
        }

        pub async fn send(self) -> Result<i32, IpcError> {
            let request = SumArrayRequest::new(self.port.name(), self.data)?;

            let reply = match self.timeout {
                Some(t) => tokio::time::timeout(t, self.port.send_recv(&request))
                    .await
                    .map_err(|_| IpcError::Timeout)??,
                None => self.port.send_recv(&request).await?,
            };

            SumArrayReply::parse(&reply)
        }
    }

    /// Trait-based API
    #[async_trait::async_trait]
    pub trait ArrayTestClient {
        async fn sum_array(&self, data: &[i32]) -> Result<i32, IpcError>;
    }

    #[async_trait::async_trait]
    impl ArrayTestClient for AsyncPort {
        async fn sum_array(&self, data: &[i32]) -> Result<i32, IpcError> {
            sum_array_async(self, data).await
        }
    }
}
```

---

## Phase 4: Server-Side Traits

```rust
pub mod array_test {
    // ... (all above) ...

    // ════════════════════════════════════════════════════════════
    // Server Traits
    // ════════════════════════════════════════════════════════════

    /// Server implementation trait
    #[async_trait::async_trait]
    pub trait ArrayTestServer: Send + Sync {
        /// Implementation of sum_array
        async fn sum_array(&self, data: &[i32]) -> Result<i32, IpcError>;
    }

    /// Server dispatcher
    pub struct ArrayTestDispatcher<S: ArrayTestServer> {
        server: Arc<S>,
    }

    impl<S: ArrayTestServer> ArrayTestDispatcher<S> {
        pub fn new(server: S) -> Self {
            Self {
                server: Arc::new(server),
            }
        }

        /// Handle incoming message
        pub async fn dispatch(&self, msg: &[u8]) -> Result<Vec<u8>, IpcError> {
            // Parse header
            let header = MachMsgHeader::parse(msg)?;

            match header.id {
                SUM_ARRAY_ID => self.handle_sum_array(msg).await,
                _ => Err(IpcError::UnknownMessageId(header.id)),
            }
        }

        async fn handle_sum_array(&self, msg: &[u8]) -> Result<Vec<u8>, IpcError> {
            // Parse request
            let request = unsafe {
                &*(msg.as_ptr() as *const SumArrayRequest)
            };

            // Validate
            request.data_type.validate(
                MACH_MSG_TYPE_INTEGER_32,
                32,
                request.data_count,
            )?;

            // Call implementation
            let total = self.server.sum_array(request.data_slice()).await?;

            // Build reply
            let reply = SumArrayReply {
                header: MachMsgHeader {
                    bits: MACH_MSGH_BITS_REMOTE(request.header.bits),
                    size: size_of::<SumArrayReply>() as u32,
                    remote_port: request.header.reply_port(),
                    local_port: MACH_PORT_NULL,
                    voucher_port: MACH_PORT_NULL,
                    id: SUM_ARRAY_ID + 100,
                },
                retcode_type: MachMsgType::new_scalar(MACH_MSG_TYPE_INTEGER_32),
                retcode: KERN_SUCCESS,
                total_type: MachMsgType::new_scalar(MACH_MSG_TYPE_INTEGER_32),
                total,
            };

            // Serialize
            Ok(unsafe {
                std::slice::from_raw_parts(
                    &reply as *const _ as *const u8,
                    size_of::<SumArrayReply>(),
                ).to_vec()
            })
        }
    }
}
```

---

## Runtime Library: `mach_r::ipc`

### Core Types

```rust
// mach_r/src/ipc/types.rs

use std::fmt;

/// Mach port name (just a u32 identifier)
#[derive(Copy, Clone, Eq, PartialEq, Hash)]
#[repr(transparent)]
pub struct PortName(pub u32);

impl PortName {
    pub const NULL: Self = Self(0);
    pub const DEAD: Self = Self(!0);
}

/// Port with send right (type-state pattern)
pub struct SendRight {
    name: PortName,
    _marker: PhantomData<fn() -> ()>,  // !Send + !Sync
}

/// Port with receive right
pub struct ReceiveRight {
    name: PortName,
}

impl SendRight {
    pub fn name(&self) -> PortName {
        self.name
    }
}

impl Drop for SendRight {
    fn drop(&mut self) {
        // Deallocate send right
        unsafe {
            mach_port_deallocate(mach_task_self(), self.name.0);
        }
    }
}
```

### Message Header

```rust
// mach_r/src/ipc/message.rs

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct MachMsgHeader {
    pub bits: u32,
    pub size: u32,
    pub remote_port: PortName,
    pub local_port: PortName,
    pub voucher_port: PortName,
    pub id: u32,
}

impl MachMsgHeader {
    pub fn reply_port(&self) -> PortName {
        PortName((self.bits >> 8) & 0xFF)
    }

    pub fn parse(msg: &[u8]) -> Result<&Self, IpcError> {
        if msg.len() < size_of::<Self>() {
            return Err(IpcError::MessageTooSmall);
        }
        Ok(unsafe { &*(msg.as_ptr() as *const Self) })
    }
}
```

### Type Descriptors

```rust
// mach_r/src/ipc/descriptors.rs

#[repr(C)]
#[derive(Copy, Clone)]
pub struct MachMsgType {
    pub name: u8,      // MACH_MSG_TYPE_*
    pub size: u8,      // bit size
    pub number: u16,   // count
    pub inline_: bool,
    pub longform: bool,
    pub deallocate: bool,
    pub unused: u8,
}

impl MachMsgType {
    pub fn new_scalar(type_: u8) -> Self {
        Self {
            name: type_,
            size: match type_ {
                MACH_MSG_TYPE_INTEGER_32 => 32,
                MACH_MSG_TYPE_INTEGER_64 => 64,
                _ => 0,
            },
            number: 1,
            inline_: true,
            longform: false,
            deallocate: false,
            unused: 0,
        }
    }

    pub fn new_array(type_: u8, count: u32) -> Self {
        Self {
            name: type_,
            size: match type_ {
                MACH_MSG_TYPE_INTEGER_32 => 32,
                MACH_MSG_TYPE_INTEGER_64 => 64,
                _ => 0,
            },
            number: count as u16,
            inline_: true,
            longform: false,
            deallocate: false,
            unused: 0,
        }
    }

    pub fn validate(&self, expected_name: u8, expected_size: u8, expected_count: u32) -> Result<(), IpcError> {
        if self.name != expected_name {
            return Err(IpcError::TypeMismatch {
                expected: expected_name,
                actual: self.name,
            });
        }
        if self.size != expected_size {
            return Err(IpcError::SizeMismatch {
                expected: expected_size,
                actual: self.size,
            });
        }
        if self.number != expected_count as u16 {
            return Err(IpcError::CountMismatch {
                expected: expected_count,
                actual: self.number as u32,
            });
        }
        Ok(())
    }
}
```

---

## Error Handling with `thiserror`

```rust
// mach_r/src/error.rs

use thiserror::Error;

#[derive(Error, Debug)]
pub enum IpcError {
    #[error("mach error: {0:?}")]
    Mach(KernReturn),

    #[error("array too large: {actual} > {max}")]
    ArrayTooLarge { actual: usize, max: usize },

    #[error("message too small: expected at least {expected}, got {actual}")]
    MessageTooSmall { expected: usize, actual: usize },

    #[error("wrong message ID: expected {expected}, got {actual}")]
    WrongMessageId { expected: u32, actual: u32 },

    #[error("type mismatch: expected {expected}, got {actual}")]
    TypeMismatch { expected: u8, actual: u8 },

    #[error("size mismatch: expected {expected}, got {actual}")]
    SizeMismatch { expected: u8, actual: u8 },

    #[error("count mismatch: expected {expected}, got {actual}")]
    CountMismatch { expected: u32, actual: u32 },

    #[error("timeout")]
    Timeout,

    #[error("unknown message ID: {0}")]
    UnknownMessageId(u32),

    #[error(transparent)]
    Io(#[from] std::io::Error),
}

#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct KernReturn(pub i32);

impl KernReturn {
    pub const SUCCESS: Self = Self(0);
    pub const INVALID_ARGUMENT: Self = Self(4);
    pub const NO_SPACE: Self = Self(3);

    pub fn into_result(self) -> Result<(), IpcError> {
        if self.0 == 0 {
            Ok(())
        } else {
            Err(IpcError::Mach(self))
        }
    }
}
```

---

## Async Runtime Integration

```rust
// mach_r/src/ipc/async_port.rs

use tokio::sync::mpsc;
use std::sync::Arc;

/// Async wrapper for Mach port
pub struct AsyncPort {
    name: PortName,
    runtime: Arc<AsyncRuntime>,
}

impl AsyncPort {
    pub fn name(&self) -> PortName {
        self.name
    }

    /// Send and receive (async)
    pub async fn send_recv<T: AsRef<[u8]>>(&self, request: &T) -> Result<Vec<u8>, IpcError> {
        let (tx, rx) = tokio::sync::oneshot::channel();

        // Submit to runtime
        self.runtime.submit_request(Request {
            port: self.name,
            data: request.as_ref().to_vec(),
            reply_tx: tx,
        });

        // Wait for reply
        rx.await.map_err(|_| IpcError::Timeout)?
    }
}

/// Async IPC runtime
pub struct AsyncRuntime {
    request_tx: mpsc::UnboundedSender<Request>,
}

struct Request {
    port: PortName,
    data: Vec<u8>,
    reply_tx: tokio::sync::oneshot::Sender<Result<Vec<u8>, IpcError>>,
}

impl AsyncRuntime {
    pub fn new() -> Self {
        let (tx, mut rx) = mpsc::unbounded_channel();

        // Spawn worker thread for blocking mach_msg calls
        std::thread::spawn(move || {
            while let Some(req) = rx.blocking_recv() {
                let result = Self::blocking_send_recv(&req.data, req.port);
                let _ = req.reply_tx.send(result);
            }
        });

        Self { request_tx: tx }
    }

    fn submit_request(&self, req: Request) {
        let _ = self.request_tx.send(req);
    }

    fn blocking_send_recv(msg: &[u8], port: PortName) -> Result<Vec<u8>, IpcError> {
        // Actual mach_msg syscall
        let mut reply_buf = vec![0u8; 4096];

        unsafe {
            let ret = mach_msg(
                msg.as_ptr() as *mut _,
                MACH_SEND_MSG | MACH_RCV_MSG,
                msg.len() as u32,
                reply_buf.len() as u32,
                mig_get_reply_port(),
                MACH_MSG_TIMEOUT_NONE,
                MACH_PORT_NULL,
            );

            KernReturn(ret).into_result()?;
        }

        Ok(reply_buf)
    }
}
```

---

## Implementation Plan

### Week 1: Foundation
- [x] Add `thiserror` to Cargo.toml
- [ ] Refactor all error types to use `thiserror`
- [ ] Create `mach_r` crate structure
- [ ] Implement basic IPC types (PortName, MachMsgHeader, etc.)

### Week 2: Rust Codegen
- [ ] Implement message struct generation
- [ ] Implement sync client stub generation
- [ ] Test with simple.defs
- [ ] Test with array.defs

### Week 3: Testing
- [ ] Integration test infrastructure
- [ ] Property-based testing setup
- [ ] Test with all Apple .defs files
- [ ] Fuzz testing

### Week 4: Async
- [ ] Implement AsyncPort wrapper
- [ ] Generate async client stubs
- [ ] Tokio integration
- [ ] Server-side dispatcher

### Week 5: Advanced
- [ ] Server trait generation
- [ ] Zero-copy optimizations
- [ ] CapnProto serialization option
- [ ] Cross-platform .defs

---

## Success Criteria

- ✅ Generated Rust code is idiomatic and type-safe
- ✅ No `unsafe` in generated code (only in runtime)
- ✅ Zero-copy where possible
- ✅ Async-first API
- ✅ Comprehensive error handling
- ✅ Full test coverage
- ✅ Works with real macOS Mach kernel

---

## Next Steps

1. **Add thiserror** - Start with error handling
2. **Create mach_r crate** - Runtime library structure
3. **Implement Rust codegen** - Generate type-safe messages
4. **Integration testing** - Verify correctness
5. **Async layer** - Tokio integration
